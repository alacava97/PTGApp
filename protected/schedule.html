<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Convention Schedule</title>

	<link rel="stylesheet" href="public/styles/styles.css">
	<link rel="stylesheet" href="public/styles/buttons.css">
	<link rel="stylesheet" href="public/styles/themes.css">
	<link rel="stylesheet" href="public/styles/modals.css">
	<link rel="stylesheet" href="public/styles/nav-styles.css">
	<link rel="stylesheet" href="public/styles/schedule-styles.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
	<div id="navbar"></div>

	<header>
		<h1>Schedule</h1>
	</header>

	<section id="color-key" class="key"></section>
	<main id="color-block" class="schedule"></main>
</body>
<script src="public/js/script.js" defer></script>
<script src="public/js/modals.js" defer></script>
<script>
	document.addEventListener('DOMContentLoaded', initSchedule);

	async function initSchedule() {
		const classModal = new Modal('class-modal');
		classModal.content(`<h3>Select a Class</h3>
			<p id="period-info"></p>
			<form id="schedule-form" class="modal-form">
			    <input name="title" type="text" id="searchable" placeholder="Search classes">
				<ul id="results" class="drop-down-select"></ul>
				<div class="seperator"></div>
				<button type="submit">Add Class</button>
			</form>`);

		const eventModal = new Modal('event-modal');
		eventModal.content(`<h3><a id="class-title"></a></h3>
			<h4 id="inst"></h4>
			<a id="class-info">Review Form &#x1F517</a>
			<form id="update-sched">
				<label for="day">Day</label>
				<select id="day" name="day">
					<option value="3" selected>Wednesday</option>
					<option value="4">Thursday</option>
					<option value="5">Friday</option>
					<option value="6">Saturday</option>
				</select>
				<div class="seperator"></div>
				<label for="start_period">Period</label>
				<select id="start_period" name="start_period">
					<option value="1">Period 1</option>
					<option value="2">Period 2</option>
					<option value="3">Period 3</option>
					<option value="4">Period 4</option>
					<option value="5">Period 5</option>
				</select>
				<div class="seperator"></div>
				<label for="room_id">Room</label>
				<select name="room_id" id="room-dropdown"></select>
				<div class="seperator"></div>
				<label for="notes">Notes</label>
				<textarea name="notes" placeholder="notes" id="notes"></textarea>
				<button type="submit" id="edit-sched" class="button">Update</button>
			</form><br>
			<button id="confirm-delete" class="red delete">Delete</button>`);

		const deleteModal = new Modal('delete-confirmation-modal');
		deleteModal.content(`<h4>Remove event from calendar?</h4>
			<button id="delete-button" class="red delete">Delete</button>
		`);

		window.DOM = {
			classModal: document.getElementById('class-modal'),
			eventModal: document.getElementById('event-modal'),
			roomDropdown: document.getElementById('room-dropdown'),
			colorBlock: document.getElementById('color-block'),
			scheduleForm: document.getElementById('schedule-form'),
			searchable: document.getElementById('searchable'),
			results: document.getElementById('results'),
			periodInfo: document.getElementById('period-info'),
			classTitle: document.getElementById('class-title'),
			instructor: document.getElementById('inst'),
			classInfo: document.getElementById('class-info'),
			day: document.getElementById('day'),
			period: document.getElementById('start_period'),
			notes: document.getElementById('notes'),
			colorKey: document.getElementById('color-key'),
			deleteConfirmation: document.getElementById('delete-confirmation-modal')
		}

		try {
			const data = await ScheduleAPI.load(ScheduleState.year_id);
			await renderKey(data.types, data.conventions);
			await renderSchedule(data.schedule, data.rooms, data.periods);

			attachEventModalHandlers();
		    const delButton = document.getElementById('confirm-delete');
		    delButton.addEventListener('click', () => { document.getElementById('delete-confirmation-modal').style.display = 'flex' });

			createSearchableDropdown('searchable', 'results', data.classes, 'title');

			Object.values(data.rooms).forEach(room => {
				const opt = document.createElement('option');
				opt.value = room.id;
				opt.textContent = room.name;
				DOM.roomDropdown.appendChild(opt);
			});
		} catch (err) {
			console.error('Failed to initialize schedule:', err);
		}
	}

	/* -----------------------------
	   Data Fetching
	----------------------------- */

	async function fetchJSON(url, options = {}) {
	  	const res = await fetch(url, options);
		if (!res.ok) throw new Error(await res.text());
		return res.json();
	}

	const ScheduleAPI = {
		load: async (locationId) => {
			const [schedule, rooms, types, conventions, classes, periods] = await Promise.all([
				fetchJSON(`/api/schedule/${locationId}`),
				fetchJSON(`/api/getRooms/${locationId}`),
				fetchJSON('/api/read/types'),
				fetchJSON('/api/read/conventions'),
				fetchJSON('/api/read/classes'),
				fetchJSON('/api/read/periods')
			]);
			return { schedule, rooms, types, conventions, classes, periods };
		},

		updateTypeColor: (id, color) =>
		    fetchJSON(`/api/update/types/${id}`, {
		      	method: 'PATCH',
		      	headers: { 'Content-Type': 'application/json' },
		      	body: JSON.stringify({ color })
		    }),

	 	addSchedule: data =>
		    fetchJSON('/api/addSchedule', {
		      	method: 'POST',
		      	headers: { 'Content-Type': 'application/json' },
		      	body: JSON.stringify(data)
		    }),

		deleteSchedule: id =>
		    fetchJSON(`/api/delete/schedule/${id}`, { method: 'DELETE' })
	};


	/* -----------------------------
	   State
	----------------------------- */

	let ScheduleState = {
		selectedLocation: null,
		activeEvent: null,
		year_id: 1
	};

	/* -----------------------------
	   Page Setup
	----------------------------- */

	function renderSchedulePage({ schedule, rooms, types, conventions, periods }) {
		renderKey(types, conventions);
		renderSchedule(schedule, rooms, periods);
	}

	/* -----------------------------
	   Schedule Setup
	----------------------------- */

	async function renderSchedule(schedule, rooms, periods) {
		//render headers
		DOM.colorBlock.innerHTML = '';

		const days = ['Wednesday', 'Thursday', 'Friday', 'Saturday'];

		renderDayHeaders(DOM.colorBlock, days, periods);
		renderRooms(DOM.colorBlock, schedule, rooms, days, periods);
	}

	function renderDayHeaders(calendar, days, periods) {
		const blank = document.createElement('div');
		blank.classList.add('header', 'sched-row1', 'sched-col1');
		calendar.appendChild(blank);

		days.forEach(day => {
			const dayLabel = document.createElement('div');
			dayLabel.textContent = day;
			dayLabel.classList.add('day', 'header', 'sched-row1');
			calendar.appendChild(dayLabel);
		});

		const periodTitle = document.createElement('div');
		periodTitle.textContent = 'Period'
		periodTitle.classList.add('header', 'period', 'sched-col1');
		calendar.appendChild(periodTitle);

		for (let i = 0; i < 4; i++) {
			periods.forEach(period => {
				const block = document.createElement('div');
				block.textContent = period.period;
				block.classList.add('header', 'period');
				if (period.period == 5) {
					block.classList.add('sched-col1');
				}
				calendar.appendChild(block);
			});
		}

		const timeTitle = document.createElement('div');
		timeTitle.textContent = 'Time';
		timeTitle.classList.add('header', 'period', 'sched-col1', 'sched-row1');
		calendar.appendChild(timeTitle);

		for (let i = 0; i < 4; i++) {
			periods.forEach(period =>  {
				const [ hoursStart, minutesStart ] = period.start.split(':');
				const [ hoursEnd, minutesEnd ] = period.end.split(':');

				const periodTime = document.createElement('div');
				periodTime.classList.add('header', 'period', 'sched-row1');			
				periodTime.innerHTML = `${parseInt(hoursStart, 10)}:${minutesStart} - ${parseInt(hoursEnd, 10)}:${minutesEnd}`;
				if (period.period == 5) {
					periodTime.classList.add('sched-col1');
				}
				calendar.appendChild(periodTime);
			});
		}
	}

	function renderRooms(calendar, schedule, rooms, days, periods) {
		console.log(schedule)
		if (!rooms) {
			calendar.innerHTML = `No rooms on record`;
			calendar.style.backgroundColor = 'white';
			return
		}
		calendar.style.backgroundColor = '#333'

		rooms.forEach(room => {
			const roomEvents = schedule.filter(e => e.room_id == room.id);

			const roomLabel = document.createElement('div');
			roomLabel.innerHTML = `
				${room.name}<br>
				${room.t ?
					`${room.t || 0}-T<br>` :
					''}
				${room.c ?
					`${room.c || 0}-C<br>` :
					''}
				${room.piano || 'No Piano'}
			`;
			roomLabel.classList.add('room', 'sched-col1', 'sched-row1');
			calendar.appendChild(roomLabel);

			days.forEach((day, index) => {
				const roomDayEvents = roomEvents.filter(e => e.day == (index + 3));
				
				let p = 1;
				while (p <= periods.length) {
					const periodEvent = roomDayEvents.find(ev => ev.start_period == p);
					if (periodEvent) {
						const eventDiv = document.createElement('div');
						eventDiv.innerHTML = `
							${periodEvent.title}<br><br>
							${periodEvent.instructors.join(`<br>`)}
							${periodEvent.piano
								?`<br>${periodEvent.piano}`
								:''}
							`;

						eventDiv.classList.add('event');
						eventDiv.style.backgroundColor = periodEvent.color;
					    eventDiv.style.gridColumn = `span ${periodEvent.length}`;
					    eventDiv.id = periodEvent.schedule_id;
					    eventDiv.addEventListener('mouseenter', () => {
					    	eventDiv.style.backgroundColor = `color-mix(in srgb, ${periodEvent.color} 90%, black)`;
					    });

					    eventDiv.addEventListener('mouseleave', () => {
					    	eventDiv.style.backgroundColor = periodEvent.color;
					    })

					    const checkbox = document.createElement('input');
					    checkbox.type = 'checkbox';
					    checkbox.value = periodEvent.schedule_id;
					    checkbox.classList.add('bottom-right');
					    checkbox.checked = true;
					    checkbox.addEventListener('click', (e) => { e.stopPropagation() });
					    eventDiv.appendChild(checkbox);

					    eventDiv.addEventListener('click', () => openEventModal(periodEvent));
					    const start = Number(periodEvent.start_period);
					    const end = start + Number(periodEvent.length) - 1;

					    if (end >=5) {
					    	eventDiv.classList.add('sched-col1');
					    }

					    calendar.appendChild(eventDiv);
					    p = end + 1;
					} else {
					    const dummy = document.createElement('div');
					    dummy.textContent = p;
					    dummy.classList.add('event');
					    dummy.id = 0;
					    const currentPeriod = p;
					    if (p === 5) {
					    	dummy.classList.add('sched-col1')
					    }

					    dummy.addEventListener('click', async () => {
					      	DOM.searchable.value = '';
					     	DOM.results.innerHTML = '';
					     	DOM.classModal.style.display = 'flex';
					     	DOM.periodInfo.textContent = `${day} - Period ${currentPeriod} - ${room.name}`;
					      	DOM.scheduleForm.dataset.day = index + 3;
					      	DOM.scheduleForm.dataset.period = currentPeriod;
					      	DOM.scheduleForm.dataset.room = parseInt(room.id);
					    });

					    calendar.appendChild(dummy);
					    p++;
					}
				}
			});
		});

	}

	/* -----------------------------
	 	Modal Functions
	----------------------------- */

	function openEventModal(periodEvent) {
		activeEvent = periodEvent;
		fillEventModal(periodEvent);
		showModal('event-modal');
	}

	function showModal(modalId) {
		const eventModal = document.getElementById(modalId);
	    eventModal.style.display = 'flex';
	}

	function fillEventModal(periodEvent) {
	    DOM.classTitle.innerHTML = `${periodEvent.title} &#9998;`;
	    DOM.classTitle.href = `/class-info.html?id=${periodEvent.class_id}`

	    DOM.instructor.textContent = periodEvent.instructors;
	    DOM.classInfo.href = `/public/class-review.html?id=${periodEvent.schedule_id}`
	    DOM.day.value = periodEvent.day;
	    DOM.period.value = periodEvent.start_period;
	    DOM.roomDropdown.value = periodEvent.room_id;
	    DOM.notes.value = periodEvent.notes;
	}

	function attachEventModalHandlers(periodEvent) {
		document.getElementById('update-sched').addEventListener('submit', handleUpdateSubmit);
		document.getElementById('delete-button').addEventListener('click', handleDelete);
		DOM.scheduleForm.addEventListener('submit', handleCreateSubmit);
	}

	async function handleCreateSubmit(e) {
		e.preventDefault();

	    const { schedule, classes } = await ScheduleAPI.load(ScheduleState.year_id);

	    const dpr = e.target.dataset
	    const cId = DOM.searchable.getAttribute('row-id');

        const selectedClass = classes.find(c => c.id == parseInt(cId));
	    if (!selectedClass) {
	    	alert(`Class "${selectedClass.title}" not found`);
	        return;
	    }

	    const length = selectedClass.length;
	    const end = Number(dpr.period) + length - 1;

	    if (end > 5) {
	        alert(`Cannot schedule "${selectedClass.title}" after period 5`);
	        return;
	    }

      	const r = schedule.filter(e => e.day == dpr.day && e.room_id == dpr.room);


		const conflict = findScheduleConflict(
			{
				day: dpr.day,
				room: dpr.room,
				period: dpr.period,
				length
			},
			schedule
		);

		if (conflict) {
		  	alert(
		    	`Cannot add "${selectedClass.title}" because it overlaps with "${conflict.title}" at period ${conflict.start_period}`
		  	);
		  	return;
		}

		const instConflict = findInstructorConflict(
			{
				day: dpr.day,
				instructorId: selectedClass.instructor_ids,
				period: dpr.period,
				length: selectedClass.length
			},
				schedule
		);

		console.log(instConflict)

		if (instConflict) {
			alert(
				`Cannot schedule "${selectedClass.title}" because ${instConflict.instructor_name} is already scheduled in ${instConflict.room}`
			);
			return
		}

      	await ScheduleAPI.addSchedule({
	      	class_id: cId,
	      	day: dpr.day,
	      	start_period: dpr.period,
	      	room: dpr.room
      	});

      	alert('Class added!');
      	DOM.classModal.style.display = 'none';
      	refreshSchedule();

      	e.target.dataset.day = '';
      	e.target.dataset.period = '';
      	e.target.dataset.room = '';
      	DOM.searchable.value = '';
      	DOM.results.innerHTML = '';
	}

	async function handleUpdateSubmit(e) {
		e.preventDefault();

		if (!activeEvent) return;

		const updated = parseForm(e.target);
		const { schedule } = await ScheduleAPI.load(ScheduleState.year_id)

		const conflict = findScheduleConflict(
		  	{
			    day: updated.day,
			    room: updated.room_id,
			    period: updated.start_period,
			    length: activeEvent.length
		  	},
			  	schedule,
		  	{ ignoreId: activeEvent.schedule_id }
		);

		if (conflict) {
		  	alert(
		    	`Cannot move "${activeEvent.title}" because it overlaps with "${conflict.title}"`
		  	);
		  	return;
		}

		const instConflict = findInstructorConflict(
			{
				day: updated.day,
				period: updated.start_period,
				length: activeEvent.length,
				instructorId: activeEvent.instructor_id
			},
				schedule,
			{ ignoreId: activeEvent.schedule_id }
		);

		if (instConflict) {
			alert(
				`Cannot move "${activeEvent.title}" because ${instConflict.instructor_name} is already scheduled in ${instConflict.room}`
			);
			return
		}

		await fetch(`api/update/schedule/${activeEvent.schedule_id}`, {
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(updated)
		});

		DOM.eventModal.style.display = 'none';

		await refreshSchedule();
	}

	async function handleDelete() {
		if (!activeEvent) return;
		await ScheduleAPI.deleteSchedule(activeEvent.schedule_id);
		DOM.eventModal.style.display = 'none';
		DOM.deleteConfirmation.style.display = 'none';
		await refreshSchedule();
	}

	/* -----------------------------
	   	Type Legend
	----------------------------- */

	async function renderKey(types, conventions) {
		DOM.colorKey.innerHTML = '';

		const spacer = document.createElement('label');
		spacer.classList.add('key-label');
		spacer.textContent = "Select Convention";
		spacer.appendChild(await renderYearSelect());
		const vertSep = document.createElement('div');
		vertSep.classList.add('vertical-seperator');
		spacer.appendChild(vertSep);
		DOM.colorKey.appendChild(spacer);

		

		const ddLabel = document.createElement('label');
		ddLabel.classList.add('key-label');
		ddLabel.textContent = "Print Labels";

		const allNone = document.createElement('select');
		allNone.classList.add('year-select');
		const allNoneOptions = ['Select All', 'Deselect All'];
		allNoneOptions.forEach((option, index) => {
			const selectOption = document.createElement('option');
			selectOption.textContent = option;
			selectOption.value = index;
			allNone.appendChild(selectOption);
		});
		allNone.addEventListener('change', (e) => {
			const checks = document.querySelectorAll('input[type=checkbox]');
			checks.forEach(check => {
				if (e.target.value == 0) {
					check.checked = true;
				} else if (e.target.value == 1) {
					check.checked = false;
				}
			})
		})
		ddLabel.appendChild(allNone);
		ddLabel.appendChild(vertSep.cloneNode(false));
		DOM.colorKey.appendChild(ddLabel);

		const cbLabel = document.createElement('label');
		cbLabel.classList.add('key-label');
		cbLabel.textContent = "Print Color Block";
		DOM.colorKey.appendChild(cbLabel);
		DOM.colorKey.appendChild(renderPrintButton(types));

		const flexSpace = document.createElement('span');
		flexSpace.classList.add('spacer');
		DOM.colorKey.appendChild(flexSpace);

		types.forEach(type => DOM.colorKey.appendChild(renderTypeKey(type)));
	}

	async function updateTypeColor(id, val) {
		const data = { 'color': val };
		try {
			const res = await fetch(`/api/update/types/${id}`, {
				method: 'PATCH',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(data)
			});

			const result = await res.json();
			console.log(result.message || result.error || 'Unknown response');

			refreshSchedule();
		} catch (err) {
			console.error('Error updating schedule:', err);
		}
	}

	function renderTypeKey(type) {
		const wrapper = document.createElement('div');
		wrapper.className = 'key-item';
		wrapper.style.backgroundColor = type.color;

		const input = document.createElement('input');
		input.type = 'color';
		input.value = type.color;

		input.classList.add('color-select');
		input.addEventListener('change', async (event) => {
			const input = event.target;
			await updateTypeColor(type.id, input.value);
		});

		wrapper.appendChild(input);
		addTooltip(wrapper, type.type);
		return wrapper;
	}

	function renderPrintButton(types) {
		const printBtn = document.createElement('button');
		printBtn.classList.add("fa", "fa-print");
		printBtn.id = "print-schedule";

		const loading = document.createElement('div');
		loading.classList.add('loading');

		printBtn.appendChild(loading);
		printBtn.addEventListener('click', async (e) => {
			e.target.disabled = true;
			loading.style.display = 'flex';
			const blockWKey = DOM.colorBlock.cloneNode(true);
			const toPrint = document.createElement('div');

			const colorKey = document.createElement('div');
			colorKey.classList.add('flex-row', 'print-key-container');
			types.forEach(type => {
				const key = document.createElement('div');
				key.textContent = type.type;
				key.style.backgroundColor = type.color;
				key.classList.add('print-key');
				colorKey.appendChild(key);
			});

			toPrint.appendChild(colorKey);
			toPrint.appendChild(blockWKey);

			await downloadElementAsPDF(toPrint, 'colorblock');
			loading.style.display = "none";
			e.target.disabled = false;
		});

		return printBtn;
	}

	function renderPrintLabelsButton() {
		const printBtn = document.createElement('button');
		printBtn.classList.add("fa", "fa-print");
		printBtn.id = "print-schedule";

		const loading = document.createElement('div');
		loading.classList.add('loading');

		printBtn.appendChild(loading);
		printBtn.addEventListener('click', async (e) => {
			e.target.disabled = true;
			loading.style.display = 'flex';
			const toPrint = document.createElement('div');

			//get labels here

			await downloadElementAsPDF(toPrint, 'colorblock');
			loading.style.display = "none";
			e.target.disabled = false;
		});

		return printBtn;
	}

	async function renderYearSelect() {
		const yearDd = document.createElement('select');
		yearDd.classList.add('year-select');
		yearDd.id = 'year-select';

		await populateYearDropdown(yearDd, 1);

		yearDd.addEventListener('change', async (e) => {
			ScheduleState.year_id = e.target.value;
			refreshSchedule();
		});

		return yearDd;
	}

	/* -----------------------------
	 	Utilities
	----------------------------- */
	function findScheduleConflict(
		{ day, room, period, length },
		schedule,
		{ ignoredId = null } = {}
	) {
		const newStart = Number(period);
		const newEnd = newStart + Number(length) - 1;

		return schedule
			.filter(e =>
				e.day == day &&
				e.room_id == room &&
				e.id !== ignoredId
			)
			.find(event => {
				const start = Number(event.start_period);
				const end = start + Number(event.length) - 1;

				return newStart <= end && start <= newEnd;
			});
	}

	function findInstructorConflict(
		{ day, instructorId, period, length },
		schedule,
		{ ignoredId = null } = {}
	) {
		const newStart = Number(period);
		const newEnd = newStart + Number(length) - 1;

		return schedule
			.filter(e =>
				e.day == day &&
				e.id !== ignoredId &&
				(
					Array.isArray(e.instructor_ids)
						? e.instructor_ids.some(id => instructorId.includes(id))
						: e.instructor_ids.includes(event.instructor_ids)
				)
			)
			.find(event => {
				const start = Number(event.start_period);
				const end = start + Number(event.length) - 1;

				return newStart <= end && start <= newEnd;
			});
	}

	async function refreshSchedule() {
		const { schedule, rooms, periods } = await ScheduleAPI.load(ScheduleState.year_id);
  		await renderSchedule(schedule, rooms, periods);
	}

</script>
</html>